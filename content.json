{"meta":{"title":"地字第一号","subtitle":"重庆·嘉陵江·望江阁","description":"","author":"归海一刀","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2020-09-12T07:09:52.000Z","updated":"2020-09-14T07:49:27.797Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-09-14T07:49:01.000Z","updated":"2020-09-14T07:48:20.902Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"开发工具软件及IDE","slug":"开发工具软件及IDE","date":"2020-09-18T08:44:20.000Z","updated":"2020-09-18T08:45:12.717Z","comments":true,"path":"2020/09/18/开发工具软件及IDE/","link":"","permalink":"http://example.com/2020/09/18/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E5%8F%8AIDE/","excerpt":"","text":"开发工具软件及IDE​ 一款很好用的轻量级IDE VSCODE VSCODE 是由微软开发的一款IDE工具，拥有非常丰富的插件可以在线下载安装，并且启动的速度灰常快，biu~ 我一般来进行 JS、Python、Go等语言的开发。 在线代码仓库 腾讯的coding 在线的且免费使用的代码仓库，目前没有人数限制 MarkDown 编写工具 Typora 神器，目前用的最顺手的，无需解释。 跨平台的密码管理工具 BitWarDen 相比于 1Password 而言，这款工具完全免费，且功能和1password基本一模一样，该有的都有，包括win/mac、ios/Android、各种浏览器插件，使用非常方便。 移动端、小程序、公众号开发框架 Taro 目前Taro的开发支持React 及 Vue语法，并且有配套的TaroUI配合使用，记住使用Taro3需要配合TaroUI3使用，否则会报错。 后台管理框架 AntDesign Pro 蚂蚁开源，可以使用各种Antd的组件，还可以尝试 一下 antd的升级版ui组件procomponents。 免费的博客搭建工具，连域名都不用去买 hexo + github.io 基于NodeJs的hexo 配合免费的github个人页面，使用markdown来编写博客页面，编写的文章可以一键更新到网页。 开源测试工具 MeterSphere 开源的好用的一款测试工具。 一款图床工具picGo 一款win/mac都可以使用图床工具，支持多种图床源","categories":[{"name":"tools","slug":"tools","permalink":"http://example.com/categories/tools/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"JavaScript文件对象详解","slug":"JavaScript文件对象详解","date":"2020-09-18T08:34:45.000Z","updated":"2020-09-18T08:36:29.711Z","comments":true,"path":"2020/09/18/JavaScript文件对象详解/","link":"","permalink":"http://example.com/2020/09/18/JavaScript%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"JavaScript 文件对象详解在浏览器中操作文件，多数情况下用到的是 File 对象，从 &lt;input type=&#39;file&#39; /&gt; 元素获取，进而继续操作(例如将选择的图片展示在页面上，用ajax将文件上传至服务器等)。这里介绍在浏览器中操作文件的相关API. File 对象继承自 Blob 对象，先看看 Blob 对象。 1. Blob 对象Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。 Blob构造函数 Blob(array[, options]) array 是一个由ArrayBuffer, ArrayBufferView, Blob, string 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。string会被编码为UTF-8。 options 是一个可选的对象，它可能会指定如下两个属性： type，默认值为 “”，它代表了将会被放入到blob中的数组内容的MIME类型。 endings，默认值为”transparent”，用于指定包含行结束符\\n的字符串如何被写入。 它是以下两个值中的一个： “native”，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 “transparent”，代表会保持blob中保存的结束符不变。 示例: 12345var content1 = [&#x27;This is my firt trip to an island&#x27;];var blob1 = new Blob(content, &#123;type: &#x27;text/plain&#x27;&#125;);var content2 = &#123;name: &#x27;Alice&#x27;, age: 23&#125;;var blob2 = new Blob([JSON.stringify(content2, null, 2)], &#123;type: &#x27;application/json&#x27;&#125;);复制代码 Blob实例属性 属性名称 读/写 描述 size 只读 Blob 对象中所包含数据的大小（字节）。 type 只读 一个字符串，表明该Blob对象所包含数据的MIME类型。如果类型未知，则该值为空字符串。例如 “image/png”. 示例: 12345var content = [&#x27;&lt;div id=&quot;box&quot;&gt;&lt;p class=&quot;pra&quot;&gt;a paragraph&lt;/p&gt;&lt;/div&gt;&#x27;];var blob = new Blob(content, &#123;type: &#x27;text/html&#x27;&#125;);console.log(blob.size); // 50console.log(blob.type); // text/html复制代码 Blob实例方法 slice([start[, end[, contentType]]]) slice 方法接收三个可选参数，start 和 end 都是数值，表示截取的范围，contentType 指定截取的内容的 MIME 类型。返回一个新的 Blob对象。 12345var blob = new Blob([&#x27;This is an example of Blob slice method&#x27;], &#123;type: &#x27;text/plain&#x27;&#125;);console.log(blob.size); // 39var newBlob = blob.slice(10, 20, &#x27;text/plain&#x27;);console.log(newBlob.size); // 10复制代码 从 Blob 对象中读取内容可以使用 FileReader. 下文会介绍。 2. File 对象File构造函数我们接触的多数关于 File 的操作都是读取，js也为我们提供了手动创建 File 对象的构造函数：File(bits, name[, options])。 bits (required) ArrayBuffer，ArrayBufferView，Blob，或者 Array[string] — 或者任何这些对象的组合。这是 UTF-8 编码的文件内容。。 name [String] (required) 文件名称，或者文件路径. options [Object] (optional) 选项对象，包含文件的可选属性。可用的选项如下： type: string, 表示将要放到文件中的内容的MIME类型。默认值为 ‘’ 。 lastModified: 数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 Date.now()。 示例： 1var file1 = new File([&#x27;text1&#x27;, &#x27;text2&#x27;], &#x27;test.txt&#x27;, &#123;type: &#x27;text/plain&#x27;&#125;); 根据已有的 blob 对象创建 File 对象: 1var file2 = new File([blob], &#x27;test.png&#x27;, &#123;type: &#x27;image/png&#x27;&#125;); File实例属性File 对象的实例内容不可见，但是有以下属性可以访问: 属性名称 读/写 描述 name 只读 返回文件的名称.由于安全原因,返回的值并不包含文件路径 。 type 只读 返回 File 对象所表示文件的媒体类型（MIME）。例如 PNG 图像是 “image/png”. lastModified 只读 number, 返回所引用文件最后修改日期,自 1970年1月1日0:00 以来的毫秒数。 lastModifiedDate 只读 Date, 返回当前文件的最后修改日期,如果无法获取到文件的最后修改日期,则使用当前日期来替代。 示例： 12345678910&lt;input type=&quot;file&quot; id=&#x27;file&#x27;&gt;document.getElementById(&#x27;file&#x27;).addEventListener(&#x27;change&#x27;, function(event)&#123; const file = this.files[0]; if (file) &#123; console.log(file.name); console.log(file.size); console.log(file.lastModified); console.log(file.lastModifiedDate); &#125;&#125;); 备注: 基于当前的实现，浏览器不会实际读取文件的字节流，来判断它的媒体类型。它基于文件扩展来假设；将PNG 图像文件的后缀名重命名为 .txt，那么读取的该文件的 type 属性值为 “text/plain”， 而不是 “image/png” 。而且，file.type 仅仅对常见文件类型可靠。例如图像、文档、音频和视频。不常见的文件扩展名会返回空字符串。开发者最好不要依靠这个属性，作为唯一的验证方案。 File实例方法 slice([start[, end[, contentType]]]) File 对象没有定义额外的方法，由于继承了 Blob 对象，也就继承了 slice方法，用法同上文 Blob 的 slice 方法。 FileReader, URL.createObjectURL(), createImageBitmap(), 及 XMLHttpRequest.send() 都能处理 Blob 和 File。 3. FileReader 对象 FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。 其中 File 对象可以是来自用户在一个 &lt;input&gt; 元素上选择文件后返回的 FileList, 也可以来自拖放操作生成的 DataTransfer 对象,还可以是来自在一个 HTMLCanvasElement 上执行 mozGetAsFile() 方法后返回结果。 FileReader构造函数1var reader = new FileReader() 构造函数不需要传入参数，返回一个 FileReader 的实例。FileReader 继承 EventTarget对象。 FileReader实例属性 属性名称 读/写 描述 error 只读 DOMException 的实例，表示在读取文件时发生的错误 。 result 只读 文件的内容，该属性仅在读取操作完成后(load)后才有效，格式取决于读取方法 readyState 只读 表示读取文件时状态的数字 备注: readeyState的取值如下: 值 常量名 描述 0 EMPTY 还没有加载任何数据 1 LOADING 数据正在被加载 2 DONE 已完成全部的读取请求. 使用示例： 1234567var reader = new FileReader();console.log(reader.error); // nullconsole.log(reader.result); // nullconsole.log(reader.readyState); // 0console.log(reader.EMPTY); // 0console.log(reader.LOADING); // 1console.log(reader.DONE); // 2 EMPTY、LOADING、DONE 这三个属性同时存在于 FileReader 和它的的原型对象上，因此实例上有这三个属性，FileReader 对象本身也有这三个属性: 123console.log(FileReader.EMPTY); // 0console.log(FileReader.LOADING); // 1console.log(FileReader.DONE); // 2 FileReader事件文件的读取是一个异步的过程，和 XMLHttpRequest 对象一样，在读取操作过程中会触发一系列事件。 事件名称 描述 使用示例 abort 读取操作被中断时触发。 reader.onabort = function(event) &#123;&#125; error 在读取操作发生错误时触发。 reader.onerror = function(event) &#123;&#125; load 读取操作完成时触发。 reader.addEventListener(&#39;load&#39;, function(event) &#123;&#125;) loadstart 读取操作开始时触发。 reader.onloadstart = function(event) &#123;&#125; loadend 读取操作结束时（要么成功，要么失败）触发。 reader.onloadend = function(event) &#123;&#125; progress 在读取Blob时触发。 reader.onprogress = function(event) &#123;&#125; FileReader实例方法FileReader 的实例具有以下可操作的方法: 方法名称 描述 使用示例 abort() 手动终止读取操作，只有当 readyState 为 1 时才能调用，调用后，readyState 值为 2 reader.abort() readAsArrayBuffer(blob) 读取指定的 Blob 或 File 对象。读取操作完成后(触发loadend事件)，result属性将包含一个 ArrayBuffer 对象表示所读取的文件的数据。 reader.readAsArrayBuffer(blob) readAsDataURL(blob) 读取指定的 Blob 或 File 对象。读取操作完成后(触发loadend事件)，result属性将包含一个 data:URL 格式的字符串(base64编码) reader.readAsArrayBuffer(file) readAsBinaryString(blob) 已废弃，用 readAsArrayBuffer 代替 – readAsText(blob[, encoding]) 将 Blob 或者 File 对象转根据特殊的编码格式转化为内容(字符串形式), 默认编码是 utf-8 reader.readAsArrayBuffer(blob) 读取本地图片示例: 12345678910111213&lt;input type=&quot;file&quot; id=&#x27;file&#x27; accept=&quot;image/png, image/jpg, image/jpeg, image/gif&quot; /&gt;&gt;&lt;br /&gt;&gt;&lt;img src=&quot;&quot; alt=&quot;Image preview...&quot;&gt;var preview = document.querySelector(&#x27;img&#x27;);var reader = new FileReader();reader.addEventListener(&quot;load&quot;, function () &#123; preview.src = reader.result;&#125;, false);document.getElementById(&#x27;file&#x27;).addEventListener(&#x27;change&#x27;, function (event) &#123; var file = this.files[0]; if (file) &#123; reader.readAsDataURL(file); &#125;&#125;); 读取多个文件示例 - CodePen dataURL是base64编码的数据格式，展示类型为字符串，形如: data:image/jpeg;base64,/9j/4QXERXhpZgAATU... 将 dataURL 转为 blob对象: 1234567891011function dataURLToBlob (dataurl) &#123; let arr = dataurl.split(&#x27;,&#x27;); let mime = arr[0].match(/:(.*?);/)[1]; let bstr = atob(arr[1]); let n = bstr.length; let u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new Blob([u8arr], &#123; type: mime &#125;);&#125; 结合上例，根据已有的 &lt;img&gt; 对象创建一个 File 对象: 12345678reader.addEventListener(&quot;load&quot;, function () &#123; preview.src = reader.result; var blob = dataURLToBlob(reader.result); var newFile = new File([blob], &#x27;test.jpeg&#x27;, &#123;type: blob.type&#125;); console.log(newFile.name); // test.jpeg console.log(newFile.type); console.log(newFile.size);&#125;, false); URL.createObjectURL将图片文件转换成 data:URL 格式供 &lt;img&gt; 元素展示，除了使用 fileReader.readAsDataURL外，还可以使用 URL.createObjectURL方法。 URL.createObjectURL(blob) 方法返回一个 blob: 开头的字符串，指向文件在内存中的地址。 123456789&lt;input type=&quot;file&quot; id=&#x27;file&#x27; accept=&quot;image/png, image/jpg, image/jpeg, image/gif&quot; /&gt;&lt;br /&gt;&lt;img src=&quot;&quot; alt=&quot;Image preview...&quot;&gt;var preview = document.querySelector(&#x27;img&#x27;);document.getElementById(&#x27;file&#x27;).addEventListener(&#x27;change&#x27;, function (event) &#123; var file = this.files[0]; if (file) &#123; preview.src = URL.createObjectURL(file); &#125;&#125;); 综合实例综合以上，可以实现一个简单的粘贴图片并显示的功能。HTML5提供的内容编辑功能，可以粘贴部分图片，例如从网页上复制的图片。但是使用截图工具截取的图片无法粘贴显示，而且从网页上复制的图片会带有原来的样式，其图片url也是原来图片的指向。我们使用以下代码可以统一这两种粘贴操作，实现统一的效果。 123456789101112131415161718192021222324252627&lt;div id=&quot;comment&quot; contenteditable&gt;&lt;/div&gt;#comment&#123; border: 1px solid #ccc; min-height: 500px; padding: 10px;&#125;#comment:focus &#123; border-color: #ccc; outline: none;&#125;.img-paste &#123; max-width: 100%;&#125;var comment = document.getElementById(&#x27;comment&#x27;);comment.addEventListener(&#x27;paste&#x27;, function(event) &#123; console.log(event); var item = event.clipboardData.files[0]; if (item &amp;&amp; /image/.test(item.type)) &#123; var img = new Image(); img.src = URL.createObjectURL(item); img.className = &#x27;img-paste&#x27;; this.appendChild(img); event.preventDefault(); &#125;&#125;, false); 实例效果可以查看这里。 参考链接 using files from web apps - MDN Blob - MDN MIME types - Wikipedia MIME TYPES - MDN FileReader —— MDN MIME types - w3school [Blob/DataURL/canvas/image的相互转换](","categories":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"}],"tags":[{"name":"file","slug":"file","permalink":"http://example.com/tags/file/"}]},{"title":"Docker容器的使用","slug":"Docker容器的使用","date":"2020-09-14T08:23:54.000Z","updated":"2020-09-14T08:32:36.701Z","comments":true,"path":"2020/09/14/Docker容器的使用/","link":"","permalink":"http://example.com/2020/09/14/Docker%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Docker容器的使用Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。Docker通常用于如下场景： web应用的自动化打包和发布； 自动化测试和持续集成、发布； 在服务型环境中部署和调整数据库或其他的后台应用； 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。 ubuntu 上安装： wget -qO- https://get.docker.com/ | sh 或者 sudo apt-get install docker Docker系统有两个程序：docker服务端和docker客户端。其中docker服务端是一个服务进程，管理着所有的容器。docker客户端则扮演着docker服务端的远程控制器，可以用来控制docker的服务端进程。大部分情况下，docker服务端和客户端运行在一台机器上。 搜索可用的docker镜像使用docker最简单的方式莫过于从现有的容器镜像开始。Docker官方网站专门有一个页面来存储所有可用的镜像，网址是：index.docker.io。你可以通过浏览这个网页来查找你想要使用的镜像，或者使用命令行的工具来检索。目标：学会使用命令行的工具来检索名字叫做tutorial的镜像。提示：命令行的格式为：docker search 镜像名字 学会使用docker命令来下载镜像下载镜像的命令非常简单，使用docker pull命令即可。(译者按：docker命令和git有一些类似的地方）。在docker的镜像索引网站上面，镜像都是按照 用户名/ 镜像名的方式来存储的。有一组比较特殊的镜像，比如ubuntu这类基础镜像，经过官方的验证，值得信任，可以直接用 镜像名来检索到。目标：通过docker命令下载tutorial镜像。提示：执行pull命令的时候要写完整的名字，比如”learn/tutorial”。 查看安装的镜像： 在docker容器中运行hello world!docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。目标：在我们刚刚下载的镜像中输出”hello word”。为了达到这个目的，我们需要在这个容器中运行”echo”命令，输出”hello word”。提示：docker run命令有两个参数，一个是镜像名，一个是要在镜像中运行的命令。 在容器中安装新的程序下一步我们要做的事情是在容器里面安装一个简单的程序(ping)。我们之前下载的tutorial镜像是基于ubuntu的，所以你可以使用ubuntu的apt-get命令来安装ping程序：apt-get install -y ping。备注：apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。目标：在learn/tutorial镜像里面安装ping程序。提示：在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。 保存对容器的修改当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。docker中保存状态的过程称之为committing，它保存的新旧状态之间的区别，从而产生一个新的版本。目标：首先使用docker ps -l命令获得安装完ping命令之后容器的id。然后把这个镜像保存为learn/ping。提示：1. 运行docker commit，可以查看该命令的参数列表。2. 你需要指定要提交保存容器的ID。(译者按：通过docker ps -l 命令获得)3. 无需拷贝完整的id，通常来讲最开始的三至四个字母即可区分。（译者按：非常类似git里面的版本号) 运行新的镜像ok，到现在为止，你已经建立了一个完整的、自成体系的docker环境，并且安装了ping命令在里面。它可以在任何支持docker环境的系统中运行啦！(译者按：是不是很神奇呢？)让我们来体验一下吧！目标：在新的镜像中运行ping www.google.com命令。提示：一定要使用新的镜像名learn/ping来运行ping命令。(译者按：最开始下载的learn/tutorial镜像中是没有ping命令的) 查看所有的容器列表的命令是：docker ps -a ，显示最近一个容器的命令是：docker ps -l，更新太快了- - 发布docker镜像现在我们已经验证了新镜像可以正常工作，下一步我们可以将其发布到官方的索引网站。还记得我们最开始下载的learn/tutorial镜像吧，我们也可以把我们自己编译的镜像发布到索引页面，一方面可以自己重用，另一方面也可以分享给其他人使用。runoob@runoob:~# docker run -d -P training/webapp python app.py-d:让容器在后台运行。-P:将容器内部使用的网络端口映射到我们使用的主机上。docker logs [ID或者名字] 可以查看容器内部的标准输出。停止运行runoob@runoob:~$ docker stop wizardly_chandrasekhar 我们可以使用 docker rm 命令来删除不需要的容器 删除容器时，容器必须是停止状态runoob@runoob:~$ docker rm wizardly_chandrasekhar docker run 只在第一次运行时使用，将镜像放到容器中，以后再次启动这个容器时，只需要使用命令docker start 即可。docker run**相当于执行了两步操作：将镜像放入容器中（**docker create**）**,**然后将容器启动，使之变成运行时容器（**docker start**）。**","categories":[{"name":"容器","slug":"容器","permalink":"http://example.com/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"MySQL创建用户与授权","slug":"MySQL创建用户与授权","date":"2020-09-14T08:18:16.000Z","updated":"2020-09-14T08:19:12.809Z","comments":true,"path":"2020/09/14/MySQL创建用户与授权/","link":"","permalink":"http://example.com/2020/09/14/MySQL%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E4%B8%8E%E6%8E%88%E6%9D%83/","excerpt":"","text":"MySQL创建用户与授权一. 创建用户命令:CREATE USER ‘username’@’host’ IDENTIFIED BY ‘password’; 说明： username：你将创建的用户名 host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符% password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器 例子：CREATE USER ‘dog’@’localhost’ IDENTIFIED BY ‘123456’; CREATE USER ‘pig’@’192.168.1.101_’ IDENDIFIED BY ‘123456’; CREATE USER ‘pig’@’%’ IDENTIFIED BY ‘123456’; CREATE USER ‘pig’@’%’ IDENTIFIED BY ‘’; CREATE USER ‘pig’@’%’; 二. 授权:命令:GRANT privileges ON databasename.tablename TO ‘username’@’host’ 说明: privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL databasename：数据库名 tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用表示，如.* 例子: GRANT SELECT, INSERT ON test.user TO ‘pig’@’%’; GRANT ALL ON . TO ‘pig’@’%’; GRANT ALL ON maindataplus.* TO ‘pig’@’%’; 注意:用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令: GRANT privileges ON databasename.tablename TO ‘username’@’host’ WITH GRANT OPTION; 三.设置与更改用户密码命令:SET PASSWORD FOR ‘username’@’host’ = PASSWORD(‘newpassword’); 如果是当前登陆用户用: SET PASSWORD = PASSWORD(“newpassword”); 例子:SET PASSWORD FOR ‘pig’@’%’ = PASSWORD(“123456“); 四. 撤销用户权限命令:REVOKE privilege ON databasename.tablename FROM ‘username’@’host’; 说明:privilege, databasename, tablename：同授权部分 例子:REVOKE SELECT ON . FROM ‘pig’@’%’; 注意:假如你在给用户‘pig’@’%’授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO ‘pig’@’%’，则在使用REVOKE SELECT ON . FROM ‘pig’@’%’;命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON . TO ‘pig’@’%’;则REVOKE SELECT ON test.user FROM ‘pig’@’%’;命令也不能撤销该用户对test数据库中user表的Select权限。 具体信息可以用命令SHOW GRANTS FOR ‘pig’@’%’; 查看。 五.删除用户命令:DROP USER ‘username’@’host’;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"YML简介","slug":"YML简介","date":"2020-09-12T06:03:43.000Z","updated":"2020-09-14T08:11:01.762Z","comments":true,"path":"2020/09/12/YML简介/","link":"","permalink":"http://example.com/2020/09/12/YML%E7%AE%80%E4%BB%8B/","excerpt":"","text":"一、YML是什么YAML (YAML Ain’t a Markup Language)YAML不是一种标记语言，通常以.yml为后缀的文件，是一种直观的能够被电脑识别的数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，一种专门用来写配置文件的语言。可用于如： Java，C/C++, Ruby, Python, Perl, C#, PHP等。 二、YML的优点 YAML易于人们阅读。 YAML数据在编程语言之间是可移植的。 YAML匹配敏捷语言的本机数据结构。 YAML具有一致的模型来支持通用工具。 YAML支持单程处理。 YAML具有表现力和可扩展性。 YAML易于实现和使用。 三、YML语法1.约定 k: v 表示键值对关系，冒号后面必须有一个空格 使用空格的缩进表示层级关系，空格数目不重要，只要是左对齐的一列数据，都是同一个层级的 大小写敏感 缩进时不允许使用Tab键，只允许使用空格。 松散表示，java中对于驼峰命名法，可用原名或使用-代替驼峰，如java中的lastName属性,在yml中使用lastName或 last-name都可正确映射。 2.键值关系(以java语言为例，其它语言类似)对于键与值主要是看能否表示以下内容。普通的值(数字、字符串、布尔)、日期、对象、数组、集合等。 1) 普通值(字面量)k: v：字面量直接写； 字符串默认不用加上单引号或者双绰号； “”: 双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 12345name1: zhangsanname2: &#x27;zhangsan \\n lisi&#x27;name3: &quot;zhangsan \\n lisi&quot;age: 18flag: true 2)日期1date: 2020/09/12 3)对象(属性和值)、Map(键值对) 在下一行来写对象的属性和值的关系，注意缩进 123people: name: zhangsan age: 20 行内写法: 1people: &#123;name:zhangsan,age: 20&#125; 4)数组、list、set用- 值表示数组中的一个元素 1234pets: - dog - pig - cat 行内写法 1pets: [dog,pig,cat] 5)数组对象、list对象、set对象123456peoples: - name: zhangsan age: 22 - name: lisi age: 20 - &#123;name: wangwu,age: 18&#125; 6)java代码示例java代码(省略get,set方法) 12345678910111213141516public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Dog&gt; lists; private Dog dog; private String[] arr;｝public class Dog &#123; private String name; private Integer age;&#125; 对应的yml 123456789101112131415161718person: boss: false maps: k1: v1 k2: 14 lists: - name: d1 age: 2 - name: d2 age: 3 - &#123;name: d3,age: 4&#125; birth: 2020/09/12 dog: name: p_dog age: 15 age: 13 last-name: 张三 arr: [s1,s2,s3] 3.文档块对于测试环境，预生产环境，生产环境可以使用不同的配置，如果只想写到一个文件中，yml与是支持的,每个块用—-隔开 12345678910111213141516171819server: port: 8081spring: profiles: active: prod #激活对应的文档块---server: port: 8083spring: profiles: dev #指定属于哪个环境---server: port: 8084spring: profiles: prod #指定属于哪个环境","categories":[{"name":"脚本","slug":"脚本","permalink":"http://example.com/categories/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"YML","slug":"YML","permalink":"http://example.com/tags/YML/"}]},{"title":"hexo+github.io博客搭建📖","slug":"hexo-github-io博客搭建","date":"2020-09-11T09:17:59.000Z","updated":"2020-09-14T08:11:28.939Z","comments":true,"path":"2020/09/11/hexo-github-io博客搭建/","link":"","permalink":"http://example.com/2020/09/11/hexo-github-io%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"什么是 Hexo？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 需要安装的软件环境 Node.js [nodeJS官网] https://nodejs.org/en/ 安装 hexo： npm install hero-cli -g 使用hexo创建博客目录并启动： hexo init myBlog cd myBlog yarn hexo s 更换hexo主题：git形式： cd 到博客主目录下 git clone https://github.com/theme-next/hexo-theme-next themes/next 修改根目录下的配置文件 [_config.yml] 中 theme: next 然后启动 hexo clean hero s 部署截图 配置网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 keywords 网站的关键词。支援多个关键词。 author 您的名字 language 网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。 timezone 网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 pretty_urls 改写 permalink 的值来美化 URL pretty_urls.trailing_index 是否在永久链接中保留尾部的 index.html，设置为 false 时去除 true pretty_urls.trailing_html 是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效) 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹，source_dir 下的子目录 downloads/code i18n_dir 国际化（i18n）文件夹 :lang 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true external_link.enable 在新标签中打开链接 true external_link.field 对整个网站（site）生效或仅对文章（post）生效 site external_link.exclude 需要排除的域名。主域名和子域名如 www 需分别配置 [] filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置, see Highlight.js section for usage guide 发布文章文章资源文件夹 对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。 1post_asset_folder: true 当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。 相关文档[hexo中文文档：] https://hexo.io/zh-cn/docs/","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-09-11T03:40:32.735Z","updated":"2020-09-11T03:40:32.736Z","comments":true,"path":"2020/09/11/hello-world/","link":"","permalink":"http://example.com/2020/09/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"tools","slug":"tools","permalink":"http://example.com/categories/tools/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/categories/javascript/"},{"name":"容器","slug":"容器","permalink":"http://example.com/categories/%E5%AE%B9%E5%99%A8/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"脚本","slug":"脚本","permalink":"http://example.com/categories/%E8%84%9A%E6%9C%AC/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"file","slug":"file","permalink":"http://example.com/tags/file/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"},{"name":"YML","slug":"YML","permalink":"http://example.com/tags/YML/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}