<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":2},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="地字第一号">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="地字第一号">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="归海一刀">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>地字第一号</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="地字第一号" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">地字第一号</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">重庆·嘉陵江·望江阁</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/25/serverless/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="归海一刀">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地字第一号">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/25/serverless/" class="post-title-link" itemprop="url">Serverless</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-25 09:02:38 / 修改时间：09:09:59" itemprop="dateCreated datePublished" datetime="2020-09-25T09:02:38+08:00">2020-09-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="最近关于-Serverless-的讨论越来越多。看似与前端关系不大的-Serverless，其实早已和前端有了颇深渊源，并且将掀起新的前端技术变革。此次分享根据个人理解和总结，从前端开发模式在serverless的演进、Serverless-常见服务商提供的解决方案以及-基于Serverless-的前端开发模式等方面，与大家探讨-Serverless-中的前端开发模式。"><a href="#最近关于-Serverless-的讨论越来越多。看似与前端关系不大的-Serverless，其实早已和前端有了颇深渊源，并且将掀起新的前端技术变革。此次分享根据个人理解和总结，从前端开发模式在serverless的演进、Serverless-常见服务商提供的解决方案以及-基于Serverless-的前端开发模式等方面，与大家探讨-Serverless-中的前端开发模式。" class="headerlink" title="最近关于 Serverless 的讨论越来越多。看似与前端关系不大的 Serverless，其实早已和前端有了颇深渊源，并且将掀起新的前端技术变革。此次分享根据个人理解和总结，从前端开发模式在serverless的演进、Serverless 常见服务商提供的解决方案以及 基于Serverless 的前端开发模式等方面，与大家探讨 Serverless 中的前端开发模式。"></a>最近关于 Serverless 的讨论越来越多。看似与前端关系不大的 Serverless，其实早已和前端有了颇深渊源，并且将掀起新的前端技术变革。此次分享根据个人理解和总结，从前端开发模式在serverless的演进、Serverless 常见服务商提供的解决方案以及 基于Serverless 的前端开发模式等方面，与大家探讨 Serverless 中的前端开发模式。</h4><h3 id="一、前端开发模式的演进"><a href="#一、前端开发模式的演进" class="headerlink" title="一、前端开发模式的演进"></a>一、前端开发模式的演进</h3><p><img src="/2020/09/25/serverless/serverless1.jpg" alt="img"></p>
<h4 id="首先回顾一下前端开发模式的演进，我觉得主要有四个阶段。。"><a href="#首先回顾一下前端开发模式的演进，我觉得主要有四个阶段。。" class="headerlink" title="首先回顾一下前端开发模式的演进，我觉得主要有四个阶段。。"></a>首先回顾一下前端开发模式的演进，我觉得主要有四个阶段。。</h4><p>1、基于模板渲染的动态页面<br> 2、基于 AJAX 的前后端分离<br> 3、基于 Node.js 的前端工程化<br> 4、基于 Node.js 的全栈开发</p>
<h4 id="基于模板渲染的动态页面"><a href="#基于模板渲染的动态页面" class="headerlink" title="基于模板渲染的动态页面"></a>基于模板渲染的动态页面</h4><p>在早起的互联网时代，我们的网页很简单，就是一些静态或动态的页面，主要目的是用来做信息的展示和传播。这个时候开发一个网页也很easy，主要就是通过 JSP、PHP 等技术写一些动态模板，然后通过 Web Server（nginx，apache） 将模板解析成一个个 HTML 文件，浏览器只负责渲染这些 HTML 文件。这个阶段还没有前后端的分工，通常是后端工程师顺便写了前端页面。</p>
<p>JSP: Java Server Page: Java服务端页面，在html页面中编写Java代码的页面<br> WebServer：网站服务器或web服务器</p>
<h4 id="基于-AJAX-的前后端分离"><a href="#基于-AJAX-的前后端分离" class="headerlink" title="基于 AJAX 的前后端分离"></a>基于 AJAX 的前后端分离</h4><p>2005 年 AJAX 技术的正式提出，翻开了 Web 开发的新篇章。基于 AJAX，我们可以把 Web 分为前端和后端，前端负责界面和交互，后端负责业务逻辑的处理。前后端通过接口进行数据交互。我们也不再需要在各个后端语言里面写着难以维护的 HTML。网页的复杂度也由后端的 Web Server 转向了浏览器端的 JavaScript。也正因如此，开始有了前端这个职位。</p>
<h4 id="基于-Node-js-的前端工程化"><a href="#基于-Node-js-的前端工程化" class="headerlink" title="基于 Node.js 的前端工程化"></a>基于 Node.js 的前端工程化</h4><p>2009年 Node.js 的出现，对于前端来说，也是一个历史性的时刻。随着 Node.js 一同出现的还有 CommonJS 规范和 npm 包管理机制。随后也出现了 Grunt、Gulp、Webpack 等一系列基于 Node.js 的前端开发构建工具。</p>
<p>在 2013 年前后，前端三大框架 React.js/Angular/Vue.js 相继发布第一个版本。我们可以从以往基于一个个页面的开发，变为基于一个个组件进行开发。开发完成后使用 webpack 等工具进行打包构建，并通过基于 Node.js 实现的命令行工具将构建结果发布上线。前端开发开始变得规范化、标准化、工程化。</p>
<h4 id="基于-Node-js-的全栈开发"><a href="#基于-Node-js-的全栈开发" class="headerlink" title="基于 Node.js 的全栈开发"></a>基于 Node.js 的全栈开发</h4><p>Node.js 对前端的重要意义还有，以往只能运行在浏览器中的 js 也可以运行在服务器上，前端可以用自己最熟悉的语言来写服务端的代码。于是前端开始使用 Node.js 做全栈开发，开始由前端向全栈的方向转变。这是前端主动突破自己的边界。<br> 另一方面，前端在发展，后端也在发展。也差不多在 Node.js 诞生那个时代，后端普遍开始由<code>巨石应用模式</code>向<code>微服务架构</code>转变。这也就导致以往的前后端分工出现了分歧。随着微服务架构的兴起，后端的接口渐渐变得原子性，微服务的接口也不再直接面向页面，前端的调用变得复杂了。于是 BFF（Backend For Frontend）架构出现了，在微服务和前端中间，加了一个 BFF 层，由 BFF 对接口进行聚合、裁剪后，再输出给前端。而 BFF 这层不是后端本质工作，且和前端的关系最大，所以前端自然而然选择了 Node.js 来实现。这也是当前 Node.js 在服务端较为广泛的应用的原因。</p>
<h6 id="巨石应用：大部分web工程是将所有的功能模块-service-side-打包到一起并放在一个web容器中运行，很多企业的Java应用程序打包为war包"><a href="#巨石应用：大部分web工程是将所有的功能模块-service-side-打包到一起并放在一个web容器中运行，很多企业的Java应用程序打包为war包" class="headerlink" title="巨石应用：大部分web工程是将所有的功能模块(service  side)打包到一起并放在一个web容器中运行，很多企业的Java应用程序打包为war包"></a>巨石应用：大部分web工程是将所有的功能模块(service  side)打包到一起并放在一个web容器中运行，很多企业的Java应用程序打包为war包</h6><h6 id="微服务架构：微服务架构是一种架构理念，是指将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。把一个大型的单体应用程序和服务拆分为数个或数十个的微小型服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。"><a href="#微服务架构：微服务架构是一种架构理念，是指将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。把一个大型的单体应用程序和服务拆分为数个或数十个的微小型服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。" class="headerlink" title="微服务架构：微服务架构是一种架构理念，是指将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。把一个大型的单体应用程序和服务拆分为数个或数十个的微小型服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。"></a>微服务架构：微服务架构是一种架构理念，是指将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。把一个大型的单体应用程序和服务拆分为数个或数十个的微小型服务，它可扩展单个组件而不是整个的应用程序堆栈，从而满足服务等级协议。</h6><h4 id="下一代前端开发模式"><a href="#下一代前端开发模式" class="headerlink" title="下一代前端开发模式"></a>下一代前端开发模式</h4><p>说完了这几个阶段，可以看到，每一次前端开发模式的变化，都因某个变革性的技术而起。先是 AJAX，而后是 Node.js。那么下一个变革性的技术是什么？不言而喻，个人觉得就是 Serverless。</p>
<h4 id="什么是serverless"><a href="#什么是serverless" class="headerlink" title="什么是serverless"></a>什么是serverless</h4><p><img src="/2020/09/25/serverless/serverless2.jpg" alt="img"></p>
<p>image.png</p>
<p>CNCF，全称Cloud Native Computing Foundation（云原生计算基金会），成立于 2015 年7月21日（于美国波特兰OSCON 2015上宣布），其最初的口号是坚持和整合开源技术来让编排容器作为微服务架构的一部分，其作为致力于云原生应用推广和普及的一支重要力量，不论您是云原生应用的开发者、管理者还是研究人员都有必要了解。</p>
<p>目前行业可能更多处在容器 Docker+Kubernetes, 利用<br> IaaS、PaaS和SaaS 来快速搭建部署应用</p>
<p>基础架构即服务（Infrastructure as a Service，IaaS）、平台即服务（Platform as a Service，PaaS）以及软件即服务（Software as a Service，SaaS）。</p>
<h6 id="Docker是一个平台，它主要是提供一些服务，任何一台装有docker的机器你都可以建立、发布、运行你的应用程序，使用docker很省钱省时。"><a href="#Docker是一个平台，它主要是提供一些服务，任何一台装有docker的机器你都可以建立、发布、运行你的应用程序，使用docker很省钱省时。" class="headerlink" title="Docker是一个平台，它主要是提供一些服务，任何一台装有docker的机器你都可以建立、发布、运行你的应用程序，使用docker很省钱省时。"></a>Docker是一个平台，它主要是提供一些服务，任何一台装有docker的机器你都可以建立、发布、运行你的应用程序，使用docker很省钱省时。</h6><h6 id="简单的介绍Kubernetes。它就是一套成熟的商用服务编排解决方案。Kubernetes定位在Paas层，重点解决了微服务大规模部署时的服务编排问题。"><a href="#简单的介绍Kubernetes。它就是一套成熟的商用服务编排解决方案。Kubernetes定位在Paas层，重点解决了微服务大规模部署时的服务编排问题。" class="headerlink" title="简单的介绍Kubernetes。它就是一套成熟的商用服务编排解决方案。Kubernetes定位在Paas层，重点解决了微服务大规模部署时的服务编排问题。"></a>简单的介绍Kubernetes。它就是一套成熟的商用服务编排解决方案。Kubernetes定位在Paas层，重点解决了微服务大规模部署时的服务编排问题。</h6><h4 id="其实-Serverless-早已和前端产生了联系，只是我们可能没有感知。"><a href="#其实-Serverless-早已和前端产生了联系，只是我们可能没有感知。" class="headerlink" title="其实 Serverless 早已和前端产生了联系，只是我们可能没有感知。"></a>其实 Serverless 早已和前端产生了联系，只是我们可能没有感知。</h4><p>1、CDN: 相信大家都使用过 CDN，我们开发完成之后，直接将静态文件部署到 CDN 上，通过 CDN 进行内容分发、网络加速，在这个过程中，前端不需要关心 CDN 有多少个节点、如何做负载均衡，也不需要知道 CDN 的 QPS 是多少。所以从这个角度来说，CDN 是一种 serverless 的实现。</p>
<p>2、再比如对象存储，和 CDN 一样，我们只需要将文件上传到对象存储，就可以直接使用了，不需要关心它如何存取文件、如何进行权限控制，所以对象存储对前端来说是 Serverless。<br> 3、甚至一些第三方的 API 服务，也是 Serverless，因为我们使用的时候，不需要去关心服务器。</p>
<p><img src="/2020/09/25/serverless/serverless3.jpg" alt="img"></p>
<p>image.png</p>
<h4 id="当然，有了体感还不够，我们还是需要一个更精确的定义。从技术角度来说，Serverless-就是-FaaS-和-BaaS-的结合。"><a href="#当然，有了体感还不够，我们还是需要一个更精确的定义。从技术角度来说，Serverless-就是-FaaS-和-BaaS-的结合。" class="headerlink" title="当然，有了体感还不够，我们还是需要一个更精确的定义。从技术角度来说，Serverless 就是 FaaS 和 BaaS 的结合。"></a>当然，有了体感还不够，我们还是需要一个更精确的定义。从技术角度来说，Serverless 就是 FaaS 和 BaaS 的结合。</h4><p>简单来讲，FaaS（Function as a Service） 就是一些运行函数的平台，比如阿里云的函数计算、AWS 的 Lambda 等。</p>
<p>BaaS（Backend as a Service）则是一些后端云服务，比如云数据库、对象存储、消息队列等。利用 BaaS，可以极大简化我们的应用开发难度。</p>
<p>Serverless 则可以理解为运行在 FaaS 中，使用了 BaaS 的函数。</p>
<h4 id="Serverless-的主要特点有："><a href="#Serverless-的主要特点有：" class="headerlink" title="Serverless 的主要特点有："></a>Serverless 的主要特点有：</h4><p>1、事件驱动—-函数在 FaaS 平台中，需要通过一系列的事件来驱动函数执行。<br> 2、无状态—-因为每次函数执行，可能使用的都是不同的容器，无法进行内存或数据共享。如果要共享数据，则只能通过第三方服务，比如 ```Redis`` 等。</p>
<h6 id="Redis（全称：Remote-Dictionary-Server-远程字典服务）是一个开源的使用ANSI-C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value-数据库-，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。"><a href="#Redis（全称：Remote-Dictionary-Server-远程字典服务）是一个开源的使用ANSI-C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value-数据库-，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。" class="headerlink" title="Redis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value[数据库]，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。"></a>Redis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用ANSI <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value[数据库]，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。</h6><p>3、无运维—-使用serverless我们不需要关心服务器，也不需要关心运维，这也是serverles思想的核心；<br> 4、低成本—-使用 Serverless 成本很低，因为我们只需要为每次函数的运行付费。函数不运行，则不花钱，也不会浪费服务器资源过度</p>
<p>？？？？哪些公司平台提供这些功能???现有的服务商 云平台 亚马</p>
<h3 id="二-Serverless-常见服务商提供的解决方案"><a href="#二-Serverless-常见服务商提供的解决方案" class="headerlink" title="二 Serverless 常见服务商提供的解决方案"></a>二 Serverless 常见服务商提供的解决方案</h3><p><img src="/2020/09/25/serverless/serverless4.jpg" alt="img"></p>
<p>image.png</p>
<p>1、上图是当前主要的一些 Serverless 服务，以及对应的服务解决方案。<br> 2、从下往上，分别是基础设施、开发工具和应用场景。<br> 亚马逊-微软-谷歌<br> 3、基础设施主要是一些云计算厂商提供，包括云计算平台和各种 BaaS 服务，以及运行函数的 FaaS 平台。<br> 前端主要是 Serverless 的使用者，所以对前端来说，最重要的开发工具这一层，我们需要依赖开发工具进行 Serverless 开发、调试和部署。<br> 4、框架（Framework）<br> 如今还没有一个统一的 Serverless 标准，不同云计算平台提供的 Serverless 服务很可能是不一样的，这就导致我们的代码，无法平滑迁移。Serverless 框架一个主要功能是简化 Serverless 开发、部署流程，另一主要功能则是屏蔽不同 Serverless 服务中的差异，让我们的函数能够在不改动或者只改动很小一部分的情况下，在其他 Serverless 服务中也能运行。常见的 Serverless 框架有 Serverless Framework、ZEIT Now、Apex 等。不过这些基本都是国外公司做的，国内还没有这样的平台。<br> 5、Web IDE<br> 和 Serverless 紧密相关的 Web IDE 主要也是各个云计算平台的 Web IDE。利用 Web IDE，我们可以很方便地在云端开发、调试函数，并且可以直接部署到对应的 FaaS 平台。这样的好处是避免了在本地安装各种开发工具、配置各种环境。常见的 Web IDE 有 AWS 的 Cloud9、阿里云的函数计算 Web IDE、腾讯云的 Cloud Studio。<br> 6、当然，目前最主要的开发方式还是在本地进行开发。所以在本地开发 Serverless 的命令行工具也必不可少。<br> 命令行工具主要有两类，一类是云计算平台提供的，如 AWS 的 aws、 Azure 的 az、阿里云的 fun；还有一类是 Serverless 框架提供的，如 serverless、now。<br> 大部分工具如 serverless、fun 等，都是用 Node.js 语言来实现的。<br> 7、应用场景<br> 在开发工具上面一层，则是 Serverless 的一些垂直应用场景。除了使用传统的服务端开发，目前使用 Serverless 技术的还有小程序开发，未来可能还会涉及到物联网领域（IoT）。</p>
<h4 id="不同-Serverless-服务的对比"><a href="#不同-Serverless-服务的对比" class="headerlink" title="不同 Serverless 服务的对比"></a>不同 Serverless 服务的对比</h4><p><img src="/2020/09/25/serverless/serverless5.jpg" alt="img"></p>
<p>image.png</p>
<p>上图从支持语言、触发器、价格等多个方面对不同 Serverless 服务进行了对比，可以发现有差异，也有共性。</p>
<p>1、比如几乎所有 Serverless 服务都支持 Node.js/Python/Java 等语言。</p>
<p>2、从支持的触发器来看，几乎所有服务也都支持 HTTP、对象存储、定时任务、消息队列等触发器。当然，这些触发器也与平台自己的后端服务相关，比如阿里云的对象存储触发器，是基于阿里云的 OSS 产品的存取等事件触发的；而 AWS 的对象存储触发器，则是基于 AWS 的 S3 的事件触发的，两个平台并不通用。这也是当前 Serverless 面临的一个问题，就是标准不统一。</p>
<h4 id="S3-Amazon-Simple-Storage-Service-Amazon-S3-是一种对象存储服务，提供行业领先的可扩展性、数据可用性、安全性和性能"><a href="#S3-Amazon-Simple-Storage-Service-Amazon-S3-是一种对象存储服务，提供行业领先的可扩展性、数据可用性、安全性和性能" class="headerlink" title="S3:Amazon Simple Storage Service (Amazon S3) 是一种对象存储服务，提供行业领先的可扩展性、数据可用性、安全性和性能"></a>S3:Amazon Simple Storage Service (Amazon S3) 是一种对象存储服务，提供行业领先的可扩展性、数据可用性、安全性和性能</h4><p>从计费的角度来看，各个平台的费用基本一致。在前面也提到，Serverless 的计费是按调用次数计费，执行时长。</p>
<h3 id="三-基于-Serverless-的前端开发模式"><a href="#三-基于-Serverless-的前端开发模式" class="headerlink" title="三 基于 Serverless 的前端开发模式"></a>三 基于 Serverless 的前端开发模式</h3><h4 id="serverless-开发流程"><a href="#serverless-开发流程" class="headerlink" title="serverless 开发流程"></a>serverless 开发流程</h4><p><img src="/2020/09/25/serverless/serverless6.jpg" alt="img"></p>
<p>image.png</p>
<p>1、在开始具体的案例之前，先看一下传统开发流程。<br> 在传统开发流程中，我们需要前端写页面，后端工程师写接口。后端写完接口之后，把接口部署了，再进行前后端联调。联调完毕后再测试、上线。上线之后，还需要运维工程师对系统进行维护。整个过程涉及多个不同角色，链路较长，沟通协调也是一个问题。</p>
<p>2、而基于 Serverless，后端变得非常简单了，以往的后端应用被拆分为一个个函数，只需要写完函数并部署到 Serverless 服务即可，后续也不用关心任何服务器的运维操作。后端开发的门槛大幅度降低了。因此，只需要一个前端就可以完成所有的开发工作。<br> 当然，前端基于 Serverless 去写后端，最好也需要具备一定的后端知识。涉及复杂的后端系统或者 Serverless 不适用的场景，还是需要后端开发。</p>
<h3 id="serverless带来的价值"><a href="#serverless带来的价值" class="headerlink" title="serverless带来的价值"></a>serverless带来的价值</h3><p>1．降低运营复杂度</p>
<p>Serverless架构使软件应用和服务器实现了解耦，服务器不再是用户开发和运营应用的焦点。在应用上线前，用户无须再提前规划服务器的数量和规格。在运维过程中，用户无须再持续监控和维护具体服务器的状态，只需要关心应用的整体状态。应用运营的整体复杂度下降，用户的关注点可以更多地放在软件应用的体验和改进以及其他能带来更高业务价值的地方。<br> 2．降低运营成本<br> 服务器不再是用户关注的一个受管资源，运营的复杂度下降，应用运营所需要投入的时间和人力将大大降低。在最好的情况下，可以做到少数几个应用管理员即可管理一个处理海量请求的应用系统。</p>
<p>3、缩短产品的上市时间<br> 在Serverless架构下，应用的功能被解构成若干个细颗粒度的无状态函数，功能与功能之间的边界变得更加清晰，功能模块之间的耦合度大大减小。这使得软件应用的开发效率更高，应用开发的迭代周期更短。</p>
<h3 id="serverless实践"><a href="#serverless实践" class="headerlink" title="serverless实践"></a>serverless实践</h3><h4 id="基于-Serverless-的-BFF-Backend-For-Frontend"><a href="#基于-Serverless-的-BFF-Backend-For-Frontend" class="headerlink" title="基于 Serverless 的 BFF (Backend For Frontend)"></a>基于 Serverless 的 BFF (Backend For Frontend)</h4><p><img src="/2020/09/25/serverless/serverless7.jpg" alt="img"></p>
<p>image.png</p>
<h4 id="传统-BFF-Backend-For-Frontend-架构"><a href="#传统-BFF-Backend-For-Frontend-架构" class="headerlink" title="传统 BFF (Backend For Frontend) 架构"></a>传统 BFF (Backend For Frontend) 架构</h4><p>1、一方面，对不同的设备需要使用不同的 API，另一方面，由于微服务导致前端接口调用的复杂，所以前端开始使用 BFF 的方式，对接口进行聚合裁剪，以得到适用于前端的接口。<br> 2、最底层的就是各种后端微服务，最上层就是各种前端应用。在微服务和应用之前，就是通常由前端开发的 BFF。<br> -手机端-web端-嵌入式-<br> 这样的架构解决了接口协调的问题，但也带来了一些新的问题。</p>
<h4 id="传统-BFF-Backend-For-Frontend-的痛点"><a href="#传统-BFF-Backend-For-Frontend-的痛点" class="headerlink" title="传统 BFF (Backend For Frontend) 的痛点"></a>传统 BFF (Backend For Frontend) 的痛点</h4><p>比如针对每个设备开发一个 BFF 应用，也会面临一些重复开发的问题。而且以往前端只需要开发页面，关注于浏览器端的渲染即可，现在却需要维护各种 BFF 应用。以往前端也不需要关心并发，现在并发压力却集中到了 BFF 上。总的来说运维成本非常高，通常前端并不擅长运维。</p>
<p>Serverless 则可以帮我们很好的解决这些问题。用Serverless，我们可以用一个个函数来实各个接口的聚合裁剪。前端向 BFF 发起的请求，就相当于是 FaaS 的一个 HTTP 触发器，触发一个函数的执行，这个函数中来实现针对该请求的业务逻辑，比如调用多个微服务获取数据，然后再将处理结果返回给前端。这样运维的压力，就由以往的 BFF Server 转向了 FaaS 服务，前端再也不用关心服务器了。</p>
<h4 id="基于-Serverless-的-BFF-架构"><a href="#基于-Serverless-的-BFF-架构" class="headerlink" title="基于 Serverless 的 BFF 架构"></a>基于 Serverless 的 BFF 架构</h4><p>上图则是基于 Serverless 的 BFF 架构。为了更好的管理各种 API，我们还可以添加网关层，通过网关来管理所有 API（比如阿里云的网关），比如对 API 进行分组、分环境。基于 API 网关，前端就不直接通过 HTTP 触发器来执行函数，而是将请求发送至网关，再由网关去触发具体的函数来执行。<br> API Gateway<br> 在没有API网关作为统一出口的情况下，需要调用方自己组合各种服务，而且容易让调用方感知后端各种服务的存在，各个需要各个做很多相同的工作。<br> 加入API Gateway之后的作用<br> 一般也会把路由，安全，限流，缓存，日志，监控，重试，熔断等都放到 API 网关来做，然后服务层就完全脱离这些东西，纯粹的做业务，也能够很好的保证业务代码的干净，不用关心安全，压力等方面的问题。</p>
<h4 id="基于-Serverless-的服务端渲染"><a href="#基于-Serverless-的服务端渲染" class="headerlink" title="基于 Serverless 的服务端渲染"></a>基于 Serverless 的服务端渲染</h4><h4 id="传统服务端渲染"><a href="#传统服务端渲染" class="headerlink" title="传统服务端渲染"></a>传统服务端渲染</h4><p>基于当下最流行的三大前端框架（React.js/Anguler/Vue.js），现在的渲染方式大部分都是客户端渲染。页面初始化的时候，只加载一个简单 HTML 以及对应的 JS 文件，再由 JS 来渲染出一个个页面。这种方式最主要的问题就是白屏时间和 SEO 搜索引擎优化</p>
<p>为了解决这个问题，前端又开始尝试服务端渲染。本质思想其实和最早的模板渲染是一样的。都是前端发起一个请求，后端 Server 解析出一个 HTML 文档，然后再返回给浏览器。只不过以往是 JSP、PHP 等服务端语言的模板，现在是基于 React、Vue 等实现的同构应用，这也是如今的服务端渲染方案的优势。</p>
<p>但服务端渲染又为前端带来了一些额外的问题：运维成本，前端需要维护用于渲染的服务器。</p>
<h4 id="基于serverless的服务端渲染"><a href="#基于serverless的服务端渲染" class="headerlink" title="基于serverless的服务端渲染"></a>基于serverless的服务端渲染</h4><p>Serverless 最大的优点就是可以帮我们减少运维，那 Serverless 能不能用于服务端渲染呢？当然也是可以的。</p>
<p>传统的服务端渲染，每个请求的 path 都对应着服务端的每个路由，由该路由实现对应 path 的 HTML 文档渲染。用于渲染的服务端程序，就是这些集成了这些路由的应用。<br> 使用 Serverless 来做服务端渲染，就是将以往的每个路由，都拆分为一个个函数，再在 FaaS 上部署对应的函数。这样用户请求的 path，对应的就是每个单独的函数。通过这种方式，就将运维操作转移到了 FaaS 平台，前端做服务端渲染，就不用再关心服务端程序的运维部署了。</p>
<h4 id="基于-Serverless-的小程序开发"><a href="#基于-Serverless-的小程序开发" class="headerlink" title="基于 Serverless 的小程序开发"></a>基于 Serverless 的小程序开发</h4><p>1、目前国内使用 Serverless 较多的场景可能就是小程开发了。具体的实现就是小程序云开发，支付宝小程序和微信小程序都提供了云开发功能。<br> 2、在传统的小程序开发中，我们需要前端进行小程序端的开发；后端进行服务端的开发。小程序的后端开发和其他的后端应用开发，本质是是一样的，需要关心应用的负载均衡、备份冗灾、监控报警等一些列部署运维操作。如果开发团队人很少，可能还需要前端去实现服务端。<br> 但基于云开发，就只需要让开发者关注于业务的实现，由一个前端就能够完成整个应用的前后端开发。因为云开发将后端封装为了 BaaS 服务，并提供了对应的 SDK 给开发者，开发者可以像调用函数一样使用各种后端服务。应用的运维也转移到了提供云开发的服务商。<br> 下面分别是使用支付宝云开发的一些例子，函数就是定义在 FaaS 服务中的函数。</p>
<p>负载均衡（Load Balance）其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务<br> 备份冗灾：就是为了防止出现自然或者社会灭害带来的对存储设备的损害而造成对数据丢失,而采取的备份.</p>
<h4 id="通用-Serverless-架构"><a href="#通用-Serverless-架构" class="headerlink" title="通用 Serverless 架构"></a>通用 Serverless 架构</h4><p>基于上述几个 Serverless 开发的例子，就可以总结出一个通用的 Serverless 架构。</p>
<p><img src="/2020/09/25/serverless/serverless8.jpg" alt="img"></p>
<p>image.png</p>
<p>其中最底层就是实现复杂业务的后端微服务（Backend）。然后 FaaS 层通过一系列函数实现业务逻辑，并为前端直接提供服务。对于前端开发者来说，前端可以通过编写函数的方式来实现服务端的逻辑。</p>
<p>同时不管是在后端、FaaS 还是前端，我们都可以去调用云计算平台提供的 BaaS 服务，大大降低开发难度、减少开发成本。小程序云开发，就是直接在前端调用 BaaS 服务的例子。</p>
<h3 id="一句话总结serverless-less-is-more"><a href="#一句话总结serverless-less-is-more" class="headerlink" title="一句话总结serverless - less is more"></a>一句话总结serverless - less is more</h3><p>使用 Serverless，我们不需要再过多关注服务端的运维，不需要关心我们不熟悉的领域，我们只需要专注于业务的开发、专注于产品的实现。我们需要关心的事情变少了，但我们能做的事情更多了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/24/%E4%B8%AD%E9%97%B4%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="归海一刀">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="地字第一号">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/24/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="post-title-link" itemprop="url">中间件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-24 15:18:44 / 修改时间：15:23:13" itemprop="dateCreated datePublished" datetime="2020-09-24T15:18:44+08:00">2020-09-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="中间件是什么"><a href="#中间件是什么" class="headerlink" title="中间件是什么"></a>中间件是什么</h2><p>中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。</p>
<p>执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或 OS 环境。</p>
<p>中间件是介于操作系统和应用软件之间，为应用软件提供服务功能的软件，有消息中间件，交易中间件，应用服务器等。由于介于两种软件之间，所以，称为中间件。</p>
<h2 id="为什么使用中间件"><a href="#为什么使用中间件" class="headerlink" title="为什么使用中间件"></a>为什么使用中间件</h2><p>具体地说，中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担。</p>
<p>中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。</p>
<h2 id="主要中间件的分类"><a href="#主要中间件的分类" class="headerlink" title="主要中间件的分类"></a>主要中间件的分类</h2><h4 id="1-Hadoop"><a href="#1-Hadoop" class="headerlink" title="1. Hadoop"></a>1. Hadoop</h4><p>当一个大的任务由一台机器在规定的时间内不能完成时，人们就要采用分布式计算，即很多台机器联合起来共同完成任务。换句话说，就是把大任务拆分成许多个小任务，然后再把这些小任务分配给多台计算机去完成。参与计算的多台计算机组成一个分布式系统，需要运行一系列的分布式基础算法。</p>
<p>Hadoop 就是一个分布式计算平台，用 <a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 语言开发，包含 Common、MapReduce 和 HDFS 三个核心部件（HDFS 和 MapReduce 是最核心的两个部件）。其中：</p>
<ul>
<li>Common 为 Hadoop 的其他项目提供了一些常用工具，主要包括系统配置工具 Configuration、远程过程调用 RPC、序列化机制和 Hadoop 抽象文件系统等。</li>
<li>MapReduce 是处理海量数据的计算模型。</li>
<li>而 HDFS 用于存储海量数据，它具备高度容错性，能在低成本的通用硬件机器上稳定运行。</li>
</ul>
<p>Hadoop 实现了分布式计算中的基础算法（如一致算法、选举算法、故障检测、快照等），同时为用户提供了编程和命令接口。程序员调用这些函数能轻松写出分布式应用程序，我们都知道，如果一切从头开始，要完成一个分布式程序的编写是异常艰难的。</p>
<p>Hadoop 在海量非结构化数据处理方面能充分展示它的优势，如消费者购买行为分析、商品推荐、关键词检索、信贷风险评估等。</p>
<p>如图 1 所示，Hadoop 其实就是一个分布式计算平台，它“覆盖”在操作系统之上，向上提供函数调用（API）和命令接口，在水平方向完成分布式系统的基础算法。作为编程人员和用户，只要了解 API 和命令即可。</p>
<p><img src="/2020/09/24/%E4%B8%AD%E9%97%B4%E4%BB%B6/middle1.jpg" alt="Hadoop"><br>图 1 Hadoop</p>
<p>基于 Hadoop 平台衍生出来的开源项目主要有 Yarn、<a target="_blank" rel="noopener" href="http://c.biancheng.net/hbase/">HBase</a>、Hive、ZooKeeper、Avro、Sqoop、Mahout、Crossbow 等。</p>
<p>以 Hadoop 为基础的生态目前已经成为<a target="_blank" rel="noopener" href="http://c.biancheng.net/big_data/">大数据</a>的标准方案，被广泛用于金融、市场、电信、交通等行业的海量数据分析，在即将到来的大数据时代，它将会发挥更大的作用。</p>
<p>在中国，很多行业（如银行、电信、移动、电力、石油、交通等）沉淀了大量的业务数据，对这些海量数据进行挖掘和分析，将会带来巨大的价值。</p>
<p>用 Hadoop 构建的应用实例对于计算资源的消耗具备两个明显的特征：</p>
<ul>
<li>资源需求大：表明 Hadoop 需要大量的存储、计算和网络带宽。</li>
<li>资源需求具备季节性：表明除存储需求是经常性占用外，在运行 Mapreduce 时才需要大量的计算和网络资源，而分析大量数据的工作并不是经常性的——称为季节性</li>
</ul>
<p>因此，<a target="_blank" rel="noopener" href="http://c.biancheng.net/cloud_computing/">云计算</a>是大数据天生的计算资源供应途径，云计算的资源弹性很好地满足了大数据的季节性计算资源需求。也就是说，大数据是云计算经典的应用案例。当然，也可以按照大数据对计算资源的波峰需求静态配给计算资源，但是这种方案会造成资源的巨大浪费。</p>
<h4 id="2-LVS"><a href="#2-LVS" class="headerlink" title="2. LVS"></a>2. LVS</h4><p>LVS 是 Linux Virtual Server 的首字母缩写，意为 Linux 虚拟服务器，即把许多台物理 Linux 计算机逻辑上整合成一台超级计算机，对用户来说感觉只有一台计算能力很强的服务器，如图 2 所示。</p>
<p>LVS 就是一个由软件实现的负载均衡器，工作在网络 OSI 的第四层（应用层），是中国人章嵩开发的，代码已经并入了 Linux 内核。利用它，再加上一台廉价的计算机，就能构建一台企业级的负载均衡器。而那些外国大公司的负载均衡器，售价都要十几万元，甚至几十万元，便宜的也要几万元，LVS 出来后，这些产品都不得不降价。</p>
<p>负载均衡器的作用就是把任务分配给最合适的服务器。比如一个大型购物网店，有 100 台同样配置的服务器在运行，如果某一时刻有 10 万用户在线购物，那么通过负载均衡器，每台服务器差不多承担 1000 个在线购物用户。</p>
<p>LVS 的官网网站是 <a target="_blank" rel="noopener" href="http://www.linuxvirtualserver.org/">http：//www.linuxvirtualserver.org</a>。另外，两个较为流行的第七层负载均衡器是 Nginx 和 HAProxy，针对应用做均衡，所以能适应的负载种类没有 LVS 多。</p>
<p><img src="/2020/09/24/%E4%B8%AD%E9%97%B4%E4%BB%B6/middle2.gif" alt="LVS原理图"><br>图 2 LVS原理图</p>
<h4 id="3-Linux-HA"><a href="#3-Linux-HA" class="headerlink" title="3. Linux-HA"></a>3. Linux-HA</h4><p>也许有读者会问：“负载均衡器本身故障怎么办？”是的，如果负载均衡器出现故障，那么整个系统（如网店）将会瘫痪。所以人们开发了各种集群软件，如 Linux-HA 和 Keepalive 等，而微软干脆就在 Windows 服务器版中集成故障转移集群软件。</p>
<p>集成故障转移集群软件的核心思想是，实时检测故障机器并及时让好的机器接管工作，对外提供高可用性。Linux-HA 意为 Linux 高可用性项目，此项目具体包含如下几个组件。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Heartbeat</td>
<td>负责维护集群中各节点的信息及它们之间的心跳通信。</td>
</tr>
<tr>
<td>Pacemaker</td>
<td>集群资源管理器，是核心组件，客户端通过 Pacemaker 来配置、管理并监控整个集群。此组件的社区网站为 <a target="_blank" rel="noopener" href="http://clusterlabs.org/">http：//clusterlabs.org/</a>。OpenStack 高可用性部署实例中一般都采用 Pacemaker 和 HAProxy。</td>
</tr>
<tr>
<td>Resource Agent</td>
<td>为用于控制服务启停、监控服务状态的脚本集合，本地资源管理器（LRM）调用这些脚本来启动、停止、监控各种集群资源。</td>
</tr>
<tr>
<td>Cluster Glue</td>
<td>包含一套函数库和工具，在集群栈中，除集群消息传输（由 Heartbeat 承担）、集群资源管理（由 Pacemaker 承担）和资源代理（由 Resource Agent 承担）功能外，其他功能都由 Cluster Glue 来完成。它包含的两个主要部分是 LRM 和 Stonith，前者是本地资源管理器，后者的任务是隔离故障机器。</td>
</tr>
</tbody></table>
<p>通过心跳信号（Heartbeat）检测故障，一台好的计算机会不断向其他计算机发送心跳信号，也会接收其他计算机发送过来的心跳信息。当在规定的时间内没有收到对方计算机的心跳信号时，就启动应急预案，进一步确认故障并准备接管那台计算机的任务。</p>
<p>例如，我们采用两台 LVS 计算机，并分别安装和配置 Linux-HA，一台 LVS 计算机作为工作机，另一台作为备份机，两台 LVS 计算机互相监督对方的运行状态。当工作机故障时，备份机接管负载均衡任务并报警。相反，当备份机出故障时，只报警，提醒技术员维修备份机。</p>
<p>两台LVS计算机同时出故障是比较糟糕的情况，不过这种情况发生的概率很小，除非机房断电或者遭到雷击。对于一些非常关键的应用，可以增加参与负载均衡的服务器数量来提高可靠性，如民航飞机上采用 5 台服务器。</p>
<h4 id="4-静态网站服务器"><a href="#4-静态网站服务器" class="headerlink" title="4. 静态网站服务器"></a>4. 静态网站服务器</h4><p>我们浏览一家公司的网站时，很可能就是跟那家公司服务器上的 Apache 程序打交道，网页浏览器与 Apache 成了标准的 C/S 模式，浏览器是客户端，而 Apache 是服务端。Apache 首先把主页对应的文件 index.html 发给我们，我们看到主页内容后，点击主页上的某个链接，它又把该链接对应的文件发给我们，过程如图 3 所示。</p>
<p><img src="/2020/09/24/%E4%B8%AD%E9%97%B4%E4%BB%B6/middle3.jpg" alt="访问静态网页的过程"><br>图 3 访问静态网页的过程</p>
<p>配合 <a target="_blank" rel="noopener" href="http://c.biancheng.net/php/">PHP</a> 引擎，Apache 也支持 PHP 动态网页。过程为：</p>
<p>1）当 Apache 收到用户要浏览的 PHP 文件后，把这个 PHP 文件发给 PHP 执行引擎。</p>
<p>2）PHP 执行引擎执行该 PHP 文件，产生一个临时的静态网页文件并发回给 Apache。</p>
<p>3）最后 Apache 把这个临时的静态网页文件发给用户。</p>
<p>采用 Perl、<a target="_blank" rel="noopener" href="http://c.biancheng.net/python/">Python</a> 和 Ruby 脚本语言编写的动态网页，其工作过程与 PHP 类似。</p>
<p>Apache 是最流行的开源网站服务器，在世界排名前 100 万的网站中，有 60.6% 的网站采用 Apache；在排名前 1000 的大型网站中，Apache 占到了 34.5%，而 Ngnix 占到了 34.9%，略胜于 Apache。</p>
<h4 id="5-动态应用服务器"><a href="#5-动态应用服务器" class="headerlink" title="5. 动态应用服务器"></a>5. 动态应用服务器</h4><p>开源的动态应用服务器有 JBoss、Tomcat、Geronimo、JOnAS，关于这些项目更详细的介绍，请参考相应的官方网站。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">归海一刀</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/DJPY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;DJPY" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:dj.player.2020@gmail.com" title="E-Mail → mailto:dj.player.2020@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.djplayer.top/" title="http:&#x2F;&#x2F;www.djplayer.top" rel="noopener" target="_blank">曾经的网站(域名过期)</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">归海一刀</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  















  

  

</body>
</html>
